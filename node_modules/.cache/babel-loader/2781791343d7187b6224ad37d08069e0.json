{"ast":null,"code":"import { getAddress, isAddress } from \"@ethersproject/address\";\nimport { useEffect, useState } from \"react\"; // resolved if(name){} to not save \"\" into cache\n\n/*\n  ~ What it does? ~\n\n  Gets ENS name from given address and provider\n\n  ~ How can I use? ~\n\n  const ensName = useLookupAddress(mainnetProvider, address);\n\n  ~ Features ~\n\n  - Provide address and get ENS name corresponding to given address\n*/\n\nconst lookupAddress = async (provider, address) => {\n  if (isAddress(address)) {\n    // console.log(`looking up ${address}`)\n    try {\n      // Accuracy of reverse resolution is not enforced.\n      // We then manually ensure that the reported ens name resolves to address\n      const reportedName = await provider.lookupAddress(address);\n      const resolvedAddress = await provider.resolveName(reportedName);\n\n      if (getAddress(address) === getAddress(resolvedAddress)) {\n        return reportedName;\n      }\n\n      return getAddress(address);\n    } catch (e) {\n      return getAddress(address);\n    }\n  }\n\n  return 0;\n};\n\nconst useLookupAddress = (provider, address) => {\n  const [ensName, setEnsName] = useState(address); // const [ensCache, setEnsCache] = useLocalStorage('ensCache_'+address); Writing directly due to sync issues\n\n  useEffect(() => {\n    let cache = window.localStorage.getItem(\"ensCache_\" + address);\n    cache = cache && JSON.parse(cache);\n\n    if (cache && cache.timestamp > Date.now()) {\n      setEnsName(cache.name);\n    } else if (provider) {\n      lookupAddress(provider, address).then(name => {\n        if (name) {\n          setEnsName(name);\n          window.localStorage.setItem(\"ensCache_\" + address, JSON.stringify({\n            timestamp: Date.now() + 360000,\n            name\n          }));\n        }\n      });\n    }\n  }, [provider, address, setEnsName]);\n  return ensName;\n};\n\nexport default useLookupAddress;","map":{"version":3,"sources":["/Users/yuzucchi/Documents/operations/nft/scaffold-eth/packages/react-app/src/hooks/LookupAddress.js"],"names":["getAddress","isAddress","useEffect","useState","lookupAddress","provider","address","reportedName","resolvedAddress","resolveName","e","useLookupAddress","ensName","setEnsName","cache","window","localStorage","getItem","JSON","parse","timestamp","Date","now","name","then","setItem","stringify"],"mappings":"AAAA,SAASA,UAAT,EAAqBC,SAArB,QAAsC,wBAAtC;AACA,SAASC,SAAT,EAAoBC,QAApB,QAAoC,OAApC,C,CAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,aAAa,GAAG,OAAOC,QAAP,EAAiBC,OAAjB,KAA6B;AACjD,MAAIL,SAAS,CAACK,OAAD,CAAb,EAAwB;AACtB;AACA,QAAI;AACF;AACA;AACA,YAAMC,YAAY,GAAG,MAAMF,QAAQ,CAACD,aAAT,CAAuBE,OAAvB,CAA3B;AAEA,YAAME,eAAe,GAAG,MAAMH,QAAQ,CAACI,WAAT,CAAqBF,YAArB,CAA9B;;AAEA,UAAIP,UAAU,CAACM,OAAD,CAAV,KAAwBN,UAAU,CAACQ,eAAD,CAAtC,EAAyD;AACvD,eAAOD,YAAP;AACD;;AACD,aAAOP,UAAU,CAACM,OAAD,CAAjB;AACD,KAXD,CAWE,OAAOI,CAAP,EAAU;AACV,aAAOV,UAAU,CAACM,OAAD,CAAjB;AACD;AACF;;AACD,SAAO,CAAP;AACD,CAnBD;;AAqBA,MAAMK,gBAAgB,GAAG,CAACN,QAAD,EAAWC,OAAX,KAAuB;AAC9C,QAAM,CAACM,OAAD,EAAUC,UAAV,IAAwBV,QAAQ,CAACG,OAAD,CAAtC,CAD8C,CAE9C;;AAEAJ,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIY,KAAK,GAAGC,MAAM,CAACC,YAAP,CAAoBC,OAApB,CAA4B,cAAcX,OAA1C,CAAZ;AACAQ,IAAAA,KAAK,GAAGA,KAAK,IAAII,IAAI,CAACC,KAAL,CAAWL,KAAX,CAAjB;;AAEA,QAAIA,KAAK,IAAIA,KAAK,CAACM,SAAN,GAAkBC,IAAI,CAACC,GAAL,EAA/B,EAA2C;AACzCT,MAAAA,UAAU,CAACC,KAAK,CAACS,IAAP,CAAV;AACD,KAFD,MAEO,IAAIlB,QAAJ,EAAc;AACnBD,MAAAA,aAAa,CAACC,QAAD,EAAWC,OAAX,CAAb,CAAiCkB,IAAjC,CAAsCD,IAAI,IAAI;AAC5C,YAAIA,IAAJ,EAAU;AACRV,UAAAA,UAAU,CAACU,IAAD,CAAV;AACAR,UAAAA,MAAM,CAACC,YAAP,CAAoBS,OAApB,CACE,cAAcnB,OADhB,EAEEY,IAAI,CAACQ,SAAL,CAAe;AACbN,YAAAA,SAAS,EAAEC,IAAI,CAACC,GAAL,KAAa,MADX;AAEbC,YAAAA;AAFa,WAAf,CAFF;AAOD;AACF,OAXD;AAYD;AACF,GApBQ,EAoBN,CAAClB,QAAD,EAAWC,OAAX,EAAoBO,UAApB,CApBM,CAAT;AAsBA,SAAOD,OAAP;AACD,CA3BD;;AA6BA,eAAeD,gBAAf","sourcesContent":["import { getAddress, isAddress } from \"@ethersproject/address\";\nimport { useEffect, useState } from \"react\";\n\n// resolved if(name){} to not save \"\" into cache\n\n/*\n  ~ What it does? ~\n\n  Gets ENS name from given address and provider\n\n  ~ How can I use? ~\n\n  const ensName = useLookupAddress(mainnetProvider, address);\n\n  ~ Features ~\n\n  - Provide address and get ENS name corresponding to given address\n*/\n\nconst lookupAddress = async (provider, address) => {\n  if (isAddress(address)) {\n    // console.log(`looking up ${address}`)\n    try {\n      // Accuracy of reverse resolution is not enforced.\n      // We then manually ensure that the reported ens name resolves to address\n      const reportedName = await provider.lookupAddress(address);\n\n      const resolvedAddress = await provider.resolveName(reportedName);\n\n      if (getAddress(address) === getAddress(resolvedAddress)) {\n        return reportedName;\n      }\n      return getAddress(address);\n    } catch (e) {\n      return getAddress(address);\n    }\n  }\n  return 0;\n};\n\nconst useLookupAddress = (provider, address) => {\n  const [ensName, setEnsName] = useState(address);\n  // const [ensCache, setEnsCache] = useLocalStorage('ensCache_'+address); Writing directly due to sync issues\n\n  useEffect(() => {\n    let cache = window.localStorage.getItem(\"ensCache_\" + address);\n    cache = cache && JSON.parse(cache);\n\n    if (cache && cache.timestamp > Date.now()) {\n      setEnsName(cache.name);\n    } else if (provider) {\n      lookupAddress(provider, address).then(name => {\n        if (name) {\n          setEnsName(name);\n          window.localStorage.setItem(\n            \"ensCache_\" + address,\n            JSON.stringify({\n              timestamp: Date.now() + 360000,\n              name,\n            }),\n          );\n        }\n      });\n    }\n  }, [provider, address, setEnsName]);\n\n  return ensName;\n};\n\nexport default useLookupAddress;\n"]},"metadata":{},"sourceType":"module"}